"""
MNE Porting Verification Script
Generates test data for validating C++ implementation against Python MNE.

Usage:
    python gen_test_data.py
"""

import numpy as np
import scipy.signal
import os
import sys

# Add mne-python to path
mne_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../../mne-python"))
if os.path.exists(mne_path):
    sys.path.append(mne_path)
else:
    print(f"Warning: mne-python not found at {mne_path}")

try:
    from mne.time_frequency import tfr_array_morlet, morlet
except ImportError as e:
    print(f"Error importing MNE: {e}")
    # Fallback or exit?
    # For verification, we strictly need MNE to generate ground truth.
    # But maybe the user has 'mne' installed in the env separately?
    try:
        from mne.time_frequency import tfr_array_morlet, morlet
    except ImportError:
        print("Could not import mne. Please ensure mne-python is in the path or installed.")
        sys.exit(1)

OUTPUT_DIR = "data"

def ensure_dir(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)

def generate_signal(n_samples=1000, sfreq=1000):
    """Generate a composite signal with known frequencies."""
    t = np.arange(n_samples) / sfreq
    # Signal: 10Hz + 20Hz + 50Hz noise
    sig = (np.sin(2 * np.pi * 10 * t) + 
           0.5 * np.sin(2 * np.pi * 20 * t) + 
           0.2 * np.random.randn(n_samples))
    return t, sig

def save_data(name, data):
    """Save numpy array to text file compatible with IOUtils::read_eigen_matrix."""
    filepath = os.path.join(OUTPUT_DIR, f"{name}.txt")
    # Save as space-separated values
    # Add header with dimensions
    header = f"Dimensions (rows x cols): {data.shape[0] if data.ndim > 1 else data.size} x {data.shape[1] if data.ndim > 1 else 1}\nDescription: Generated by gen_test_data.py"
    np.savetxt(filepath, data, header=header)
    print(f"Saved {name} to {filepath}")

def main():
    ensure_dir(OUTPUT_DIR)
    
    # 1. Basic Signal
    sfreq = 1000
    n_samples = 1000
    t, sig = generate_signal(n_samples, sfreq)
    
    save_data("signal_raw", sig)
    
    # 2. Hilbert Transform (Envelope)
    # Using scipy.signal.hilbert
    sig_analytic = scipy.signal.hilbert(sig)
    amplitude_envelope = np.abs(sig_analytic)
    save_data("signal_hilbert_abs", amplitude_envelope)
    
    # 3. Convolution (Simple Moving Average)
    # Window size 50 samples
    window = np.ones(50) / 50.0
    sig_conv = np.convolve(sig, window, mode='same')
    save_data("signal_conv_ma50", sig_conv)
    
    # 4. Window Functions
    n_win = 512
    # Hanning
    win_hanning = np.hanning(n_win)
    save_data("window_hanning_512", win_hanning)
    
    # Hamming
    win_hamming = np.hamming(n_win)
    save_data("window_hamming_512", win_hamming)
    
    # Blackman
    win_blackman = np.blackman(n_win)
    save_data("window_blackman_512", win_blackman)
    
    # 5. Phase 2: TFR
    print("Generating Phase 2 (TFR) data...")
    
    # 5.1 Morlet Wavelet
    freqs = np.array([10.0, 20.0])
    n_cycles = 5.0
    # mne.time_frequency.morlet returns list of arrays (one per freq)
    Ws = morlet(sfreq, freqs, n_cycles=n_cycles)
    
    for i, freq in enumerate(freqs):
        w = Ws[i]
        save_data(f"tfr_morlet_w_{int(freq)}hz_real", np.real(w))
        save_data(f"tfr_morlet_w_{int(freq)}hz_imag", np.imag(w))

    # 5.2 TFR Computation
    # Input needs to be (n_epochs, n_chans, n_times)
    data = sig[np.newaxis, np.newaxis, :] # 1 epoch, 1 channel
    
    # Compute TFR
    # output: (n_epochs, n_chans, n_freqs, n_times)
    power = tfr_array_morlet(data, sfreq, freqs, n_cycles=n_cycles, output='power')
    
    # Save power for each freq
    for i, freq in enumerate(freqs):
        p = power[0, 0, i, :]
        save_data(f"tfr_power_{int(freq)}hz", p)
    
    # 5.3 PSD Welch
    try:
        from mne.time_frequency import psd_array_welch
    except ImportError:
        # For older MNE or different structure
        try:
            from mne.time_frequency.psd import psd_array_welch
        except ImportError:
            print("Could not import psd_array_welch")
            psd_array_welch = None

    if psd_array_welch is not None:
        n_fft = 256
        # n_per_seg default is n_fft
        # output='power' default
        psds, freqs_psd = psd_array_welch(data, sfreq=sfreq, fmin=0, fmax=np.inf, 
                                          n_fft=n_fft, n_overlap=0, n_per_seg=n_fft, 
                                          average='mean', output='power')
        # psds: (n_epochs, n_chans, n_freqs)
        
        save_data("psd_welch_psds", psds[0, 0, :])
        save_data("psd_welch_freqs", freqs_psd)

    print("Verification data generation complete.")

if __name__ == "__main__":
    main()
