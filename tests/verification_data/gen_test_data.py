"""
MNE Porting Verification Script
Generates test data for validating C++ implementation against Python MNE.

Usage:
    python gen_test_data.py
"""

import numpy as np
from scipy import signal
import os
import sys

# Add mne-python to path
mne_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../../mne-python"))
if os.path.exists(mne_path):
    sys.path.append(mne_path)
else:
    print(f"Warning: mne-python not found at {mne_path}")

try:
    from mne.time_frequency import tfr_array_morlet, morlet
except ImportError as e:
    print(f"Error importing MNE: {e}")
    # Fallback or exit?
    # For verification, we strictly need MNE to generate ground truth.
    # But maybe the user has 'mne' installed in the env separately?
    try:
        from mne.time_frequency import tfr_array_morlet, morlet
    except ImportError:
        print("Could not import mne. Please ensure mne-python is in the path or installed.")
        sys.exit(1)

OUTPUT_DIR = "data"

def ensure_dir(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)

def generate_signal(n_samples=1000, sfreq=1000):
    """Generate a composite signal with known frequencies."""
    t = np.arange(n_samples) / sfreq
    # Signal: 10Hz + 20Hz + 50Hz noise
    sig = (np.sin(2 * np.pi * 10 * t) + 
           0.5 * np.sin(2 * np.pi * 20 * t) + 
           0.2 * np.random.randn(n_samples))
    return t, sig

def save_data(name, data):
    """Save numpy array to text file compatible with IOUtils::read_eigen_matrix."""
    filepath = os.path.join(OUTPUT_DIR, f"{name}.txt")
    # Save as space-separated values
    # Add header with dimensions
    header = f"Dimensions (rows x cols): {data.shape[0] if data.ndim > 1 else data.size} x {data.shape[1] if data.ndim > 1 else 1}\nDescription: Generated by gen_test_data.py"
    np.savetxt(filepath, data, header=header)
    print(f"Saved {name} to {filepath}")

def main():
    ensure_dir(OUTPUT_DIR)
    
    # 1. Basic Signal
    sfreq = 1000
    n_samples = 1000
    t, sig = generate_signal(n_samples, sfreq)
    
    save_data("signal_raw", sig)
    
    # 2. Hilbert Transform (Envelope)
    # Using scipy.signal.hilbert
    sig_analytic = signal.hilbert(sig)
    amplitude_envelope = np.abs(sig_analytic)
    save_data("signal_hilbert_abs", amplitude_envelope)
    
    # 3. Convolution (Simple Moving Average)
    # Window size 50 samples
    window = np.ones(50) / 50.0
    sig_conv = np.convolve(sig, window, mode='same')
    save_data("signal_conv_ma50", sig_conv)
    
    # 4. Window Functions
    n_win = 512
    # Hanning
    win_hanning = np.hanning(n_win)
    save_data("window_hanning_512", win_hanning)
    
    # Hamming
    win_hamming = np.hamming(n_win)
    save_data("window_hamming_512", win_hamming)
    
    # Blackman
    win_blackman = np.blackman(n_win)
    save_data("window_blackman_512", win_blackman)
    
    # 5. Phase 2: TFR
    print("Generating Phase 2 (TFR) data...")
    
    # 5.1 Morlet Wavelet
    freqs = np.array([10.0, 20.0])
    n_cycles = 5.0
    # mne.time_frequency.morlet returns list of arrays (one per freq)
    Ws = morlet(sfreq, freqs, n_cycles=n_cycles)
    
    for i, freq in enumerate(freqs):
        w = Ws[i]
        save_data(f"tfr_morlet_w_{int(freq)}hz_real", np.real(w))
        save_data(f"tfr_morlet_w_{int(freq)}hz_imag", np.imag(w))

    # 5.2 TFR Computation
    # Input needs to be (n_epochs, n_chans, n_times)
    data = sig[np.newaxis, np.newaxis, :] # 1 epoch, 1 channel
    
    # Compute TFR
    # output: (n_epochs, n_chans, n_freqs, n_times)
    power = tfr_array_morlet(data, sfreq, freqs, n_cycles=n_cycles, output='power')
    
    # Save power for each freq
    for i, freq in enumerate(freqs):
        p = power[0, 0, i, :]
        save_data(f"tfr_power_{int(freq)}hz", p)
    
    # 5.3 PSD Welch
    try:
        from mne.time_frequency import psd_array_welch
    except ImportError:
        # For older MNE or different structure
        try:
            from mne.time_frequency.psd import psd_array_welch
        except ImportError:
            print("Could not import psd_array_welch")
            psd_array_welch = None

    if psd_array_welch is not None:
        n_fft = 256
        # n_per_seg default is n_fft
        # output='power' default
        psds, freqs_psd = psd_array_welch(data, sfreq=sfreq, fmin=0, fmax=np.inf, 
                                          n_fft=n_fft, n_overlap=0, n_per_seg=n_fft, 
                                          average='mean', output='power')
        # psds: (n_epochs, n_chans, n_freqs)
        
        save_data("psd_welch_psds", psds[0, 0, :])
        save_data("psd_welch_freqs", freqs_psd)

    # 6. ICA
    print("Generating Phase 3 (ICA) data...")
    # Generate synthetic sources
    n_samples = 2000
    time = np.linspace(0, 8, n_samples)
    
    s1 = np.sin(2 * time)  # Sinusoid
    s2 = np.sign(np.sin(3 * time))  # Square wave
    s3 = signal.sawtooth(2 * np.pi * time)  # Sawtooth
    
    S = np.c_[s1, s2, s3]
    S += 0.2 * np.random.normal(size=S.shape)  # Add noise
    S /= S.std(axis=0)  # Standardize
    
    # Mixing matrix
    A = np.array([[1, 1, 1], [0.5, 2, 1.0], [1.5, 1.0, 2.0]])  # 3 channels, 3 sources
    X = np.dot(S, A.T)  # (n_samples, n_channels)
    
    # MNE expects (n_channels, n_samples)
    X_mne = X.T
    
    save_data("ica_mixed_signal", X_mne)
    save_data("ica_true_sources", S.T)
    save_data("ica_mixing_matrix_true", A)
    
    # Run sklearn FastICA for reference
    from sklearn.decomposition import FastICA
    # sklearn FastICA takes (n_samples, n_features)
    transformer = FastICA(n_components=3, random_state=0, whiten='unit-variance')
    S_est = transformer.fit_transform(X)
    A_est = transformer.mixing_
    W_est = transformer.components_ # Unmixing * Whitening
    
    save_data("ica_sklearn_sources", S_est.T)
    save_data("ica_sklearn_mixing", A_est)
    save_data("ica_sklearn_components", W_est)

    print("Verification data generation complete.")

if __name__ == "__main__":
    main()
